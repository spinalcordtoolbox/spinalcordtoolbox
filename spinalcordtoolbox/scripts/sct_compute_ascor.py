#!/usr/bin/env python
#
# Compute adapted Spinal Cord Occupation Ratio (aSCOR) from spinal cord and spinal canal masks.
# morphometrics.
#
# Copyright (c) 2023 Polytechnique Montreal <www.neuro.polymtl.ca>
# License: see the file LICENSE

import sys
import os
import textwrap
import logging
from typing import Sequence
from spinalcordtoolbox.utils.fs import get_absolute_path, TempFolder
from spinalcordtoolbox.utils.sys import init_sct, printv, set_loglevel
from spinalcordtoolbox.utils.shell import parse_num_list, display_open, Metavar, SCTArgumentParser
from spinalcordtoolbox.utils.sys import LazyLoader
from spinalcordtoolbox.scripts import sct_process_segmentation

pd = LazyLoader("pd", globals(), "pandas")

logger = logging.getLogger(__name__)

INDEX_COLUMNS = ['Filename SC', 'Filename canal', 'Slice (I->S)', 'VertLevel', 'DistancePMJ', 'aSCOR']


# PARSER
# ==========================================================================================


def get_parser():
    """
    :return: Returns the parser with the command line documentation contained in it.
    """
    # Initialize the parser
    parser = SCTArgumentParser(
        description=textwrap.dedent("""
            Compute adapted Spinal Cord Occupation Ratio (aSCOR) from spinal cord and spinal canal segmentation masks.
            The aSCOR is defined as the ratio between the cross-sectional area of the spinal cord and the cross-sectional area of the spinal canal at the same vertebral level.
        """),  # noqa: E501 (line too long)
    )

    mandatory = parser.mandatory_arggroup
    mandatory.add_argument(
        '-i-SC',
        metavar=Metavar.file,
        help=textwrap.dedent("""
            Spinal cord segmentation mask to compute morphometrics from. If spinal cord segmentation is provided, MSCC is computed. If spinal canal segmentation (spinal cord + CSF) is provided, MCC is computed. Example: `sub-001_T2w_seg.nii.gz`
            Spinal cord segmentation can be obtained with `sct_deepseg spinalcord`.
        """),  # noqa: E501 (line too long)
    )
    mandatory.add_argument(
        '-i-canal',
        metavar=Metavar.file,
        help=textwrap.dedent("""
            Spinal canal segmentation mask to compute morphometrics from. Example: `sub-001_T2w_canal_seg.nii.gz`
            Canal segmentation can be obtained with `sct_deepseg sc_canal_t2`.
        """),  # noqa: E501 (line too long)
    )
    optional = parser.optional_arggroup
    optional.add_argument(
        '-o',
        metavar=Metavar.file,
        default='csa.csv',
        help="Output file name (add extension)."
    )
    optional.add_argument(
        '-append',
        metavar=Metavar.int,
        type=int,
        choices=[0, 1],
        default=0,
        help="Append results as a new line in the output csv file instead of overwriting it."
    )
    optional.add_argument(
        '-z',
        metavar=Metavar.str,
        type=parse_num_list,
        default='',
        help="Slice range to compute the metrics across. Example: `5:23`"
    )
    optional.add_argument(
        '-perslice',
        metavar=Metavar.int,
        type=int,
        choices=[0, 1],
        default=0,
        help="Set to 1 to output one metric per slice instead of a single output metric. Please note that when "
             "methods ml or map is used, outputting a single metric per slice and then averaging them all is not the "
             "same as outputting a single metric at once across all slices."
    )
    optional.add_argument(
        '-vert',
        metavar=Metavar.str,
        type=parse_num_list,
        default='',
        help="Vertebral levels to compute the metrics across. Example: 2:9 for C2 to T2. If you also specify a range of "
             "slices with flag `-z`, the intersection between the specified slices and vertebral levels will be "
             "considered."
    )
    optional.add_argument(
        '-vertfile',
        metavar=Metavar.str,
        help=textwrap.dedent("""
            Vertebral labeling file generated by sct_label_vertebrae or sct_warp_template. Only use with flag `-vert`.

            The input and the vertebral labelling file must be in the same voxel coordinate system and must match the dimensions between each other.
            Example: ./label/template/PAM50_levels.nii.gz
            This flag will be deprecated in favor of -discfile in the future.
        """),
    )
    optional.add_argument(
        '-discfile',
        metavar=Metavar.str,
        help=textwrap.dedent("""
            File with single-voxel labels identifying the intervertebral discs generated with sct_deepseg totalspineseg or sct_label_utils.
            Used with `-vert` to aggregate metrics within vertebral levels. Disc labels will be projected onto the spinal
            cord to identify vertebral levels.
            Example: ./label/template/PAM50_label_disc.nii.gz
        """),
    )
    optional.add_argument(
        '-perlevel',
        metavar=Metavar.int,
        type=int,
        choices=[0, 1],
        default=0,
        help="Set to 1 to output one metric per vertebral level instead of a single output metric. This flag needs "
             "to be used with flag `-vert`."
    )
    optional.add_argument(
        '-angle-corr',
        metavar=Metavar.int,
        type=int,
        choices=[0, 1],
        default=1,
        help="Angle correction for computing morphometric measures. When angle correction is used, the cord within "
             "the slice is stretched/expanded by a factor corresponding to the cosine of the angle between the "
             "centerline and the axial plane. If the cord is already quasi-orthogonal to the slab, you can set "
             "-angle-corr to 0."
    )
    optional.add_argument(
        '-angle-corr-centerline',
        metavar=Metavar.str,
        help="Image to be used as a centerline for computing angle correction (can be either a cord segmentation or a "
             "single-voxel centerline mask). This argument is optional; if not provided, the centerline will be "
             "derived from the input segmentation. Use this option if the input segmentation is irregularly shaped "
             "(e.g. gray/white matter). In such a case, it is best to pass the full cord segmentation to this option, "
             "as you will get a more accurate centerline (and thus a more accurate, consistent angle correction)."
    )
    optional.add_argument(
        '-centerline-algo',
        choices=['polyfit', 'bspline', 'linear', 'nurbs'],
        default='bspline',
        help="Algorithm for centerline fitting. Only relevant with `-angle-corr 1`."
    )
    optional.add_argument(
        '-centerline-smooth',
        metavar=Metavar.int,
        type=int,
        default=30,
        help="Degree of smoothing for centerline fitting. Only use with `-centerline-algo {bspline, linear}`."
    )
    optional.add_argument(
        '-pmj',
        metavar=Metavar.file,
        type=get_absolute_path,
        help="Ponto-Medullary Junction (PMJ) label file. "
             "Example: `pmj.nii.gz`"
    )
    optional.add_argument(
        '-pmj-distance',
        type=float,
        metavar=Metavar.float,
        help="Distance (mm) from Ponto-Medullary Junction (PMJ) to the center of the mask used to compute morphometric "
             "measures. (To be used with flag `-pmj`.)"
    )
    optional.add_argument(
        '-pmj-extent',
        type=float,
        metavar=Metavar.float,
        default=20.0,
        help="Extent (in mm) for the mask used to compute morphometric measures. Each slice covered by the mask is "
             "included in the calculation. (To be used with flag `-pmj` and `-pmj-distance`.)"
    )
    optional.add_argument(
        '-normalize-PAM50',
        metavar=Metavar.int,
        type=int,
        choices=[0, 1],
        default=0,
        help="Set to 1 to bring the metrics in the PAM50 anatomical dimensions perslice. `-vertfile` and `-perslice` need to be specified."
    )
    # Arguments which implement shared functionality
    parser.add_common_args()
    parser.add_tempfile_args()

    return parser


def compute_ascor(csa_sc, csa_canal, fname_out, append):
    """
    Computes the aSCOR (area Spinal Cord to area Canal Ratio) for each row in the provided CSV files and saves the results to a CSV file.

    :param str csa_sc: Path to the CSV file containing spinal cord area measurements.
    :param str csa_canal: Path to the CSV file containing spinal canal area measurements.
    :param str fname_out: Path to the output CSV file where the computed aSCOR values will be saved.
    :param bool append: If True, append the results to the output file; otherwise, overwrite the file.
    """
    df_sc = pd.read_csv(csa_sc)
    df_canal = pd.read_csv(csa_canal)
    df_ascor = pd.DataFrame()
    # Loop across rows in dataframe
    for idx in range(len(df_sc)):
        ascor_value = df_sc['MEAN(area)'].iloc[idx] / df_canal['MEAN(area)'].iloc[idx]
        row = [df_sc['Filename'].iloc[idx],
               df_canal['Filename'].iloc[idx],
               df_sc['Slice (I->S)'].iloc[idx],
               df_sc['VertLevel'].iloc[idx],
               df_sc['DistancePMJ'].iloc[idx],
               ascor_value]
        df_ascor = pd.concat([df_ascor, pd.DataFrame([row], columns=INDEX_COLUMNS)], ignore_index=True)
    printv(f"Computed aSCOR for {len(df_ascor)} rows.", 1, 'normal')
    # Save to csv
    save_ascor_to_csv(df_ascor, fname_out, append)


def save_ascor_to_csv(df_ascor, fname_out, append=False):
    """
    Saves the aSCOR DataFrame to a CSV file.

    :param pandas.DataFrame: df_ascor : The DataFrame containing aSCOR results to be saved.
    :param str: fname_out : Path to the output CSV file.
    :param bool: append : If True, appends `df_ascor` to the existing CSV file. If False, overwrites the file. Default is False.
    :return None

    """
    if append:
        dataframe_old = pd.read_csv(fname_out, index_col=INDEX_COLUMNS)
        df_ascor = pd.concat([dataframe_old.reset_index(), df_ascor], ignore_index=True)
    df_ascor.to_csv(fname_out, index=False)


def main(argv: Sequence[str]):
    parser = get_parser()
    arguments = parser.parse_args(argv)
    verbose = arguments.v
    set_loglevel(verbose=verbose, caller_module_name=__name__)    # values [0, 1, 2] map to logging levels [WARNING, INFO, DEBUG]

    # Load input and output filenames
    fname_sc_segmentation = get_absolute_path(arguments.i_SC)
    fname_canal_segmentation = get_absolute_path(arguments.i_canal)
    # TODO check that they are both in the same space
    fname_out = arguments.o
    temp_folder = TempFolder(basename="process-segmentation")
    path_tmp = temp_folder.get_path()
    # Run sct_process_segmentation on spinal cord segmentation
    printv("Running sct_process_segmentation on spinal cord segmentation...", verbose, 'normal')
    # Remove '-i-SC', '-o', and '-i-canal' arguments from argv before passing to sct_process_segmentation
    process_seg_argv = [a for i, a in enumerate(argv) if argv[i-1] not in ['-i-SC', '-o', '-i-canal'] and a not in ['-i-SC', '-o', '-i-canal']]
    sct_process_segmentation.main(
                                  ['-i', fname_sc_segmentation,
                                   '-o', os.path.join(path_tmp, "sc.csv"),
                                   ] + process_seg_argv  # pass all other arguments to sct_process_segmentation
    )
    # Run sct_process_segmentation on spinal canal segmentation
    printv("Running sct_process_segmentation on spinal canal segmentation...", verbose, 'normal')
    # Remove '-i-SC', '-o', and '-i-canal' arguments from argv before passing to sct_process_segmentation
    sct_process_segmentation.main(
                                  ['-i', fname_canal_segmentation,
                                   '-o', os.path.join(path_tmp, "canal.csv"),
                                   ] + process_seg_argv  # pass all other arguments to sct_process_segmentation
    )
    # Compute aSCOR
    printv("Computing aSCOR...", verbose, 'normal')
    compute_ascor(os.path.join(path_tmp, "sc.csv"), os.path.join(path_tmp, "canal.csv"), fname_out, arguments.append)
    printv(f'\nSaved: {os.path.abspath(fname_out)}')
    display_open(os.path.abspath(fname_out))
    # Clean up temp
    if arguments.r and temp_folder is not None:
        logger.info("\nRemove temporary files...")
        temp_folder.cleanup()


if __name__ == "__main__":
    init_sct()
    main(sys.argv[1:])
